# 数据类型

js 共有六种数据类型：
+ 数值（Number）：整数和小数（比如1和3.14）。
+ 字符串（String）：文本（比如Hello World）。
+ 布尔值（Boolean）：表示真伪的两个特殊值，即true和false。
+ 未定义（Undefined）：表示因为目前没有定义，所以此处暂时没有任何值。
+ 空值（Null）：表示此处的值为空。
+ 对象（Object）：各种值组成的集合。

数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。

对象是最复杂的数据类型，又可以分成三个子类型：
+ 狭义的对象（Object）。
+ 数组（Array）。
+ 函数（Function）。

# Null和Undefined

+ null 是一个表示“空”的对象，转为数值时为0。调用函数时，某个参数未设置任何值，这时就可以传入 null ，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入 null ，表示未发生错误。
+ undefined 是一个表示"此处无定义"的原始值，转为数值时为NaN。

# 布尔值Boolean

布尔值往往用于程序流程的控制，除了以下值被转换为`false`，其他值都会被转换为`true`：
+ undefined。
+ null。
+ false。
+ 0。
+ NaN。
+ ""或''。

# 数值Number

js 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0实际上是同一个数。所有数字都是浮点数，浮点数的64个二进制位，从最左边开始，是这样组成的：
+ 第1位：符号位，0表示正数，1表示负数。
+ 第2位到第12位：指数部分。
+ 第13位到第64位：小数部分（即有效数字）。

所以一个数字的实际表示形式为：`(-1)^符号位 * 1.xx...xx * 2^指数部分`。

Number 对象的`MAX_VALUE`和`MIN_VALUE`属性，返回可以表示的具体的最大值和最小值：
```javascript
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
```

数值的科学记数法：
```javascript
123e3 // 123000
123e-3 // 0.123
```

数值的进制：
```javascript
0b11 // 2进制
055 // 8进制
71 // 10进制
0xA // 16进制
```

特殊的值：
+ `NaN`是一个特殊的数值，表示无意义的数值，如`0/0`。`NaN`与任何值都不相等，包括它自己，应用`isNaN()`函数判断其是否为`NaN`。
+ `Infinity`表示无穷大，如`1/0`。`-Infinity`表示无穷小。使用`isFinite()`函数判断数值是否有穷，即是否在`Number.MIN_VALUE`和`Number.MAX_VALUE`之间。`Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值。`Infinity`与`NaN`比较，总是返回`false`。

数值相关的全局方法：
```javascript
parseInt(string, system) // 将字符串转为整数。如果参数不是字符串，则会先转为字符串再转换
parseFloat(string) // 同上，将字符串转为浮点数
isNaN(number) // 仅对数值有效
isFinite(number) // 除了(-)Infinity、NaN和undefined会返回false，其他数值都会返回true
```

# 字符串String

字符串是用单引号双引号括起来的 Unicode 字符序列，一旦创建，值不可变，如要改变值需要先销毁原来的字符串。

转义序列：
```javascript
\0 // null（\u0000）
\b // 后退键（\u0008）
\f // 换页符（\u000C）
\n // 换行符（\u000A）
\r // 回车键（\u000D）
\t // 制表符（\u0009）
\v // 垂直制表符（\u000B）
\' // 单引号（\u0027）
\" // 双引号（\u0022）
\\ // 反斜杠（\u005C）
\377 // 八进制字符
\xFF // 十六进制字符
\uFFFF // unicode字符
```

字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符。但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。其`length`属性，返回字符串的长度，该属性不可变。

# 对象Object

对象就是一组键值对（key-value）的集合，是一种无序的复合数据集合。

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

对象的每一个键名又称为属性（property），关于键名：
+ 所有键名都是字符串，所以加不加引号都可以。
+ 如果键名是数值，会被自动转为字符串。
+ 如果键名不是数字，且不符合标识名的条件，则必须加上引号，否则会报错。

对象的键值可以是任何数据类型。关于键值：
+ 如果键值为函数，则把这个属性称为方法。
+ 如果键值是一个对象，就形成了链式引用。

对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。

读取对象的属性，有两种方法：
```javascript
obj.p
obj['p'] // 方括号内部可以使用表达式
```

属性相关的操作：
```javascript
Object.keys(obj); // 查看对象所有的属性
delete obj.p // 删除p属性
'p' in obj // 检查对象是否包含p属性
obj.hasOwnProperty('p') // 检查p属性是否是obj自身的属性
```

属性的遍历（for-in循环）：
```javascript
for (var i in obj) {
	console.log('键名：', i);
	console.log('键值：', obj[i]);
}
```
+ 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
+ 它不仅遍历对象自身的属性，还遍历继承的属性。

with语句，只能操作已经存在的属性：
```javascript
with (obj) {
	p1 = 4;
	p2 = 5;
}
```
效率不高，不建议使用。

# 数组Array

数组是按次序排列的一组值。每个值的位置都有索引，整个数组用方括号表示。

数组是一种特殊的对象，它的键名是按次序排列的一组整数（0，1，2...）。

数组的`length`属性，返回数组的成员数量。该属性是一个动态的值，可读写。

forEach方法，可以用来遍历数组：
```javascript
var colors = ['red', 'green', 'blue'];
colors.forEach(function (color) {
	console.log(color);
});
```

# 函数Function

js 将函数看作一种值，与其它值地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。

函数声明有的方法：
```javascript
// function命令 会有函数名提升的现象
function print(s) {
	console.log(s);
}
// 函数表达式
var print = function(s) {
	console.log(s);
};
```

如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

参数是函数运行时，需要提供的外部数据。传递方式：
+ 参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递。因此在函数体内修改参数值，不会影响到函数外部。
+ 参数如果是复合类型的值（数组、对象、函数），传递方式是传址传递，传入函数的原始值的地址。因此在函数内部修改参数，将会影响到原始值。但如果修改的不是参数对象的某个属性，而是替换掉整个对象，则原始值不会受到影响。这是因为参数的值实际是原对象的地址，重新对参数赋值导致参数指向另一个地址，保存在原地址上的值不会受影响。

函数的属性和方法：
```javascript
name // 函数名称
length // 函数参数个数
arguments // 一个类数组对象
	length // 参数个数
	callee // 原函数
toString() // 返回字符串，内容是函数的源码
```

闭包是将函数内部和函数外部连接起来的一座桥梁。作用有两点：
1. 可以读取函数内部的变量，并让这些变量始终保持在内存中。
```javascript
function createIncrementor(start) {
	return function () {
		return start++;
	};
}
var inc = createIncrementor(5);
inc() // 5
inc() // 6
inc() // 7
```
因为`inc`始终存在在内存中，所以`createIncrementor`也始终存在。不会在调用结束后，被垃圾回收机制回收。
2. 封装对象的私有属性和私有方法。
```javascript
function Person(name) {
	var _age;
	function setAge(n) {
		_age = n;
	}
	function getAge() {
	  return _age;
	}
	return {
	  name: name,
	  getAge: getAge,
	  setAge: setAge
	};
}
var p1 = Person('张三');
p1.setAge(25);
p1.getAge(); // 25
```

立即调用的函数表达式（IIFE），有两种写法：
```javascript
(function(){ /* code */ }()); // 推荐
(function(){ /* code */ })();
```
作用有两点：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

# 类型判断

JavaScript 有三种方法，可以确定一个值的所属类型：
+ typeof运算符：数值、字符串、布尔值分别返回`number`、`string`、`boolean`，未定义返回`undefined`，空值、对象和数组返回`object`，函数返回`function`。
+ instanceof运算符。
+ Object.prototype.toString方法。

# 类型转换

强制转换：
```
Number(value) // 转换为数字
String(value) // 转换为字符串
Boolean(value) // 转换为布尔值
```

自动转换：
+ 不同类型的数据互相运算时。
+ 对非布尔值类型的数据求布尔值时（如条件判断时）。
+ 对非数值类型的值使用一元运算符（即`+`和`-`）。

具体转换规则见[这里](https://wangdoc.com/javascript/features/conversion.html)。