# 同步任务和异步任务

程序里面所有的任务，可以分为同步任务（synchronous）和异步任务（asynchronous）：
+ 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。
+ 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 AJAX 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有堵塞效应。

# 任务队列和事件循环

js 运行时，除了一个正在运行的主线程，引擎还提供多个任务队列（task queue），里面是各种需要当前程序处理的异步任务。首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

js 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。

# 异步操作的模式

1. 回调函数：回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。
```javascript
// f1是异步操作，f2是f1的回调函数
function f1(callback) {
  // ...
  callback();
}
function f2() {
  // ...
}
f1(f2);
```

2. 事件监听：这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。
```javascript
f1.on('done', f2);
function f1() {
	setTimeout(function () {
		// ...
		f1.trigger('done');
	}, 1000);
}
```

3. 发布/订阅：事件完全可以理解成信号，如果存在一个信号中心，某个任务执行完成，就向信号中心发布（publish）一个信号，其他任务可以向信号中“订阅（subscribe）这个信号，从而知道什么时候自己可以开始执行。这种方法的性质与事件监听类似，但是明显优于后者。因为可以通过查看消息中心，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。
```javascript
jQuery.subscribe('done', f2);
function f1() {
	setTimeout(function () {
		// ...
		jQuery.publish('done');
	}, 1000);
}
jQuery.unsubscribe('done', f2);
```

# 流程控制

1. 串行控制


2. 并行控制


3. 串行和并行结合控制

# 定时器

设置和清除定时器：
```javascript
// 设置定时器
// 返回一个数字作为计时器id，delay指延迟毫秒数
var timerId1 = setTimeout(func|code, delay) // 单次的定时执行
var timerId2 = setInterval(func|code, delay) // 无限次的定时执行
// 清除定时器
clearTimeout(timerId1)
clearInterval(timerId2)
```

如果回调函数是对象的方法，那么会使得方法内部的 this 关键字指向全局环境，而不是定义时所在的那个对象。可使用`bind`解决问题。

# Promise对象

